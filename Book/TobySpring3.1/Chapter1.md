# 1장 오브젝트와 의존 관계

스프링은 자바를 기반으로 한 기술이며, 자바에서 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍이 가능한 언어이다.

스프링의 핵심 철학은 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가는 것이다.

스프링의 가장 큰 관심 대상은 오브젝트이며, 이를 이해하기 위해 오브젝트의 생성, 사용, 소멸 등의 전 과정을 살펴보아야 한다.

객체 지향 설계(Object Oriented Design)의 기초와 원칙을 비롯해서, 다양한 목적을 위해 재활용 가능한 설계 방법인 디자인 패턴, 좀 더 깔끔한 구조가 되도록 지속적으로 개선해나가는 작업인 리펙토링, 오브젝트가 기대한 대로 동작하고 있는지를 효과적으로 검증하는데 쓰이는 단위 테스트와 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다.

스프링은 오브젝트의 설계, 구현, 사용, 개선 등의 효과적이며 명쾌한 기준을 제시해주며, 객체지향 기술과 설계, 구현에 관한 실용적인 전략 등을 프레임워크 형태로 제공한다.

```
자바에서 JDBC를 이용하는 작업의 일반적인 순서
- DB 연결을 위한 Connection을 가져온다.
- SQL을 담은 Statement 또는 PreparedStatement를 만든다.
- 만들어진 Statement를 실행한다.
- 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
- 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.
- JDBC API가 만들어내는 예외(Exception)를 잡아서 직접 처리하거나, 메소드에 throws를 선어내헛 예외가 발생하는 메소드 밖으로 던지게 한다.

```

-----

## 1.2 관심사의 분리

분리와 확장을 고려한 설계는 기능 변경 요구에 대해 유연하게 대처할 수 있다.

모든 변경과 발전은 한 번에 한 가지 관심 사항에 집중해서 일어난다. 여기서 문제는, 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다. 

관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

프로그래밍의 기초 개념 중에 관심사의 분리(Saparation of Concerns)가 있다. 이를 객체 지향에 적용해보면, 관심이 같은 것 끼리는 하나의 객체 안으로 또한 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이다.

여러 메소드에 중복돼서 등장하는 특저 관심 사항이 담긴 코드를 별도의 메소드로 분리하고, 이러한 작업을 통해서 추가적인 기능이 아닌 코드의 구조를 변경하여, 미래의 변화에 좀 더 손 쉽게 대응할 수 있도록 하는 작업을 리팩토링(Refactoring)이라 한다. 다시 말해 기존의 코드를 외부의 동작 방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 의미한다. 공통 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 메소드 추출(Extract Method) 기법이라 부른다. 리팩토링은 코드를 이해하기 쉽게 하며, 뱐화에 유연하게 대응할 수 있다. 생산성과 코드 품질을 향상시키며, 유지보수에 용이하고, 견고하면서 유연한 제품을 개발할 수 있다.

-----

## 1.3 확장

추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이며, 자바가 추상화를 위해 제공하는 가장 유용한 도구는 인터페이스이다. 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보를 모두 감춘다. 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때 사용할 클래스가 무엇인지 몰라도 된다.

#### 높은 응집도와 낮은 결합도 (High Cogerence and Low Coupling)

응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.

#### 높은 응집도

응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것이다. 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다는 것을 의미한다.

#### 낮은 결합도

책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해지며, 확장에 용이하다. 여기서 결합도란 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도를 의미한다.

#### 전략 패턴

자신의 기능 맥락(Context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부에 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

-----

## 1.4 제어의 역전 (IoC, Inversion of Control)

프로그램의 제어 흐름 구조가 뒤바뀌는 것이다. 제어의 역전에서 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하거나 생성하지 않으며, 어떻게 만들어지고 어디서 사용되는지 알 수 없다. 모든 제어 권한을 자신이 아닌다른 대상에게 위임하기 때문이다. 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.

제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용하도록 한다는 것이 제어의 역전 개념이며, 템플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이다.

라이브러리를 사용하는 어플리케이션 코드는 어플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용한다. 반면, 프레임워크는 거꾸로 어플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크 위에 개발한 클래스를 등록하고, 프레임워크가 흐름을 주도하는 중 개발자가 만든 어플리케이션 코드를 사용하도록 만드는 방식이다.

프레임워크에는 제어의 역전 개념이 적용되어 있어야하며, 라이브러리와의 차이점이 여기에 있다.

자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위한 과정이 바로 IoC를 적용하는 작업이다.

-----

## 1.5 스프링의 IoC

### 오브젝트 컨텍스트와 설정 정보

 스프링에서 제어권일 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean)이라 하며, 스프링 빈은 스프링 컨테이너가 생성과 관계 설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

스프링에서는 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(Bean Factory)라 부르며, 이를 확장한 어플리케이션 컨텍스트(Application Context)를 주로 사용한다. 어플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리이다.

빈 팩토리는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고, 어플리케이션 컨텍스트는 어플레케이션 전반에 걸쳐 모든 구성 요소의 제어 작업을 담당하는 IoC 엔진이라는 의미에 더 가깝다.

어플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계 설정 등의 제어 작업을 총괄하며, 별도로 설정 정보를 담고 있는 무엇인가를 가져와 이를 활용하는 범용적인 IoC 엔진 같은 것이다.

아래의 두 가지 어노테이션만으로 스프링 프레임워크의 빈 팩토리 또는 어플리케이션 컨텍스트가 IoC 방식의 기능을 제공할 때 사용할 완벽한 설정 정보가 된다.

- @Configuration - 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스 인식
- @Bean - 오브젝트를 만들어주는 메소드

###어플리케이션 컨텍스트의 동작 방식

- [어플리케이션 컨텍스트] == [IoC 컨테이너] == [스프링 컨테이너] == [빈 팩토리]

어플리케이션 컨텍스트는 일종의 빈 팩토리이며, 어플리케이셔에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계 설정을 담당한다. 직접 오브젝트를 생성하고 관계를 맺어주는 것이 아닌, 생성 정보와 연관 관계 정보를 별도의 설정 정보를 통해 얻는다. @Configuration 어노테이션이 사용된 곳이 어플리케이션 컨텍스트가 활용하는 IoC 설정 정보이다.

![어플리케이션컨텍스트동작방식](./image/어플리케이션컨텍스트동작방식.png)

#### 어플리케이션 컨텍스트 사용의 장점

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.

  오브젝트 팩토리가 아무리 많아져도 이를 알아야 하거나 직접 사용할 필요가 없다.

  어플리케이션 컨텍스트를 이용하면 일관된 방식으로 원하는 오브젝트를 가져올 수 있다.

  단순한 방법을 사용해 IoC 설정 정보를 만들 수 있다.

- 종합 IoC 서비스를 제공해준다

  어플리케이션 컨텍스트의 역할은 오브젝트의 생성, 관계 설정 뿐만 아니라, 만들어지는 방식, 시점, 전략 등을 다르게 가져갈 수 있고 자동 생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등의 다양한 기능을 제공한다.

  빈이 사용할 수 있는 기반 기술 서비스 또는 외부 시스템과의 연동 등의 컨테이너 차원에서 제공한다.

- 빈을 검색하는 다양한 방법을 제공한다.

  getbean() 메소드는 빈의 이름을 이용해 빈을 찾아주며, 타입만으로 빈을 검색하거나 특별한 어노테이션 설정이 되어 있는 빈을 찾을 수 있다.

### 스프링 IoC의 용어 정리

- 빈 (Bean)

  빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트를 뜻한다. 관리되는 오브젝트(Managed Object)라 부르기도 한다. 어플리케이션에서 만들어지는 모든 오브젝트가 모두 빈은 아니며, 그 중 스프링이 직접 생성과 제어를 담당하는 오브젝트만 빈에 해당한다.

- 빈 팩토리 (Bean Factory)

  스프링의 IoC를 담당하는 핵심 컨테이너이며, 빈의 등록, 생성, 조회, 반환 등의 부가적인 관리 기능을 담당한다. 일반적으로 빈 팩토리를 확장한 어플리케이션 컨텍스트를 사용한다.

- 어플리케이션 컨텍스트 (Application Context)

  빈 팩토리를 확장한 IoC 컨테이너로, 빈의 등록, 관리 등의 기본적인 기능 뿐만 아니라 스프링에서 제공하는 각종 부가 서비스를 제공한다. 스프링이 제공하는 어플리케이션 지원 기능을 모두 포함하며, ApplicationContext라고 적으면 어플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를 가리키는 것이다. ApplicationContext는 BeanFactory를 상속한다.

- 설정 정보 / 설정 메타 정보 (Configuration Metadata)

  어플리케이션 컨텍스트가 IoC를 적용하기 위해 사용하는 메타 정보를 말한다. 실제로 스프링의 설정 정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에 사용되며, IoC 컨테이너에 의해 관리되는 어플리케이션 오브젝트를 생성하고 구성할 때도 사용된다.

- 컨테이너(Container) 또는 IoC 컨테이너

  IoC 방식으로 빈을 관리한다는 의미로, 컨테이너는 자체적으로 IoC의 개념을 담고 있으며. 어플리케이션 컨텍스트보다 추상적인 표현이다.

- 스프링 프레임워크

  IoC 컨테이너, 어플리케이션 컨텍스트 등을 포함해서 스프링이 제공하는 모든 기능을 통틀어 말한다.

-----

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

스프링의 어플리케이션 컨텍스트는 여러번 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.

#### 오브젝트의 동일성과 동등성

자바에서 두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트인 경우 동일성(Identify) 비교라하며 == 연산자를 사용하여 비교한다. 이와 비슷하게 동일한 정보를 담고있는(equivalent) 오브젝트를 동등성(Equality) 비교라하며 equals() 메소드를 이용해 비교한다.

두 개의 요브젝트가 동일하다면 사실은 하나의 요브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모리상에 존재하는 것인데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다.

### 싱글톤 레지스트리로서의 어플리케이션 컨텍스트

어플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱그론 레지스트리(Singleton Registry)이다. 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

스프링이 주로 적용되는 대상이 자바 엔터프라이스 기술을 사용하는 서버 환경이기 때문이다.

태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될 때 그 가치가 있다.

서버는 초당 수십에서 수백개의 요청을 처리해야 하며, 이를 처리하기 위한 오브젝트 생성과 가비지 컬렉션(GC)에 의해 서버의 부하가 심해진다. 따라서 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작하며, 클래스당 하나의 오브젝트를 만들고 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

```
싱글턴 패턴 (Singleton Pattern)
싱글톤 패턴은 어떤 클래스를 어플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다.
```

스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 이를 싱글톤 레지스트리(Singleton Registry)라 한다. 스프링 컨테이너는 싱글톤을 생성, 관리, 공급받는 싱글톤 관리 컨테이너이기도 하다. 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아닌 평범함 자바 클래스를 싱글톤으로 활용하게 해준다.

싱글톤 패턴과는 달리 스프링이 지지하는 객체 지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는데 아무런 제약이 없으며, 스프링은 IoC 컨테이너일 뿐만 아니라 싱글톤 패턴 대신 싱글톤을 생성 및 관리해주는 싱글톤 레지스트리이다. 스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트의 생성 방법을 제어하는 IoC 컨테이너로서의 역할이다.

### 스프링 빈의 스코프

빈이 생성되고, 존재하고, 적용되는 범위를 스프리에서는 빈의 스코프(Scope)라 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 

경우에 따라 싱글톤 외의 스코프를 가질 수 있으며, 대표적으로 프로토타입(Prototype) 스코프가 있다. 프로토타입은 컨테이너에 빈을 요청할 때 마다 매번 새로운 오브젝트를 만들어준다. 이외에도 웹을 통해 새로운 HTTP 요청이 생길 때 마다 생성되는 요청(Request) 스코프, 웹의 세션과 스코프가 유사한 세션(Session) 스코프가 있다.

-----

## 1.7 의존관계 주입 (DI, Dependency Injection)

### 의존 관계 (Dependency Relationship)

두 개의 클래스 또는 모듈이 의존 관계에 있다고 말할 때는 항상 방향성이 부여되며, 누가 누구에게 의존하는 관계에 있어야 한다. 의존한다는 것은 의존 대상의 변화가 의존하는 개체에 영향을 미친다는 것을 의미한다.

```
[A] ------> [B]
```

의존 관계에는 방향성이 존재한다. A가 B에 의존하고 있지만, 반대로 B는 A에 의존하지 않는다. 의존하지 않는다는 것은 B는 A의 영향을 받지 않음을 의미한다.

인터페이스에 대해서만 의존 관계를 만들어주면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 되며, 결합도가 낮아진다. 의존 관계의 방향성에 의해, 인터페이스를 통한 의존 관계를 제한함으로써, 변경에 자유로워진다.

런타임 시에 의존 관계를 맺는 대상, 실제 사용 대상인 오브젝트를 의존 오브젝트(Dependent Object)라 한다. 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존 관계가 아닌 런타임 시에 오브젝트 사이에서 만들어지는 의존 관계를 의미한다.

### 의존 관계 주입 (DI, Dependency Injection)

의존 관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업의 의미한다. 의존 관계 주입은 세 가지 조건을 충족하는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존 관계가 드러나지 않는다. 그러기 위에서는 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존 관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
- 의존 관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다.

DI에서 말하는 제 3의 존재는 관계 설정 책임을 가진 코드를 분리해서 만들어진 오브젝트이다. 스프링의 어플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재에 해당한다.

두 오브젝트 사이의 런타임 의존 관계를 설정해주는 의존 관계 주입 작업을 주도하는 존재이며, 동시에 IoC 방식으로 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너를 의존 주입을 담당하는 컨테이너, 즉 DI 컨테이너라 한다. 이런 DI는 그 근간이 되는 개념인 IoC와 함께 사용해서 IoC/DI 컨테이너라 부르기도 한다. DI 컨테이너는 자신이 결정한 의존 관계를 맺어줄 클래스의 오브젝트를 만들고 이 생성자의 파라미터로 오브젝트의 레퍼런스를 전달한다. 

DI 컨테이너에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 메소드를 통해 DI 컨테이너가 주입해주는 것과 같다고해서 의존 관계 주입이라 한다.

![런타임시의의존관계주입과사용의존간계](./image/런타임시의의존관계주입과사용의존간계.png)

DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 맞다. 스프링 컨테이너의 IoC는 주로 의존 관계 주입 또는 DI라는 데 초점이 맞춰져있다.

스프링이 제공하는 기능의 99%가 DI의 혜택을 이용하고 있다. DI 없이는 스프링을 사용할 수 없다.

### 의존 관계 검색 (DL, Dependency Lookup)

의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 방법으로, 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 자신이 어떤 클래스의 오브젝트를 사용할 것인지를 결정하지는 않는다. 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.

스프링의 어플리케이션 컨텍스트는 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾는 일종의 검색을 한다. 또한 그 대상이 런타임 의존 관계를 가질 오브젝트이므로 의존 관계 검색이라 한다. 스프링의 IoC 컨테이너인 어플리케이션 컨텍스트는 getBean()이라는 메소드를 제공하며, 이 메소드가 의존 관계 검색에 사용된다.

-----

## 1.8 XML을 이용한 설정

스프링은 자바 클래스를 이용하는 것 외에도, 다양한 방법으로 DI 의존 관계 설정 정보를 만들 수 있다. 대표적으로 XML이 있다. XML은 단순한 텍스트 파일이기 때문에 다루기 쉽고, 쉽게 이해할 수 있으며, 별도의 빌드 작업이 없다는 것이 장점이다. 또한 환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 변경 사항을 빠르게 반영할 수 있다. 

DI 정보가 담긴 XMl 파일은 \<beans>를 루트 엘리먼트로 사용하며, \<beans> 안에는 여러 개의 \<bean>을 정의할 수 있다. XML 설정은 @Configuration과 @Bean이 붙은 자바 클래스로 만든 설정과 내용이 동일하다. @Configuration은 \<Beans>, @Bean은 \<bean>에 대응되며, 하나의 @Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보는 세 가지이다.

- 빈의 이름: @Bean 메소드 이름이 빈의 이름이며, getBean()에서 사용된다.
- 빈의 클래스: 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.
- 빈의 의존 오브젝트: 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다.

|         |       자바 코드 설정 정보       |         XML 설정 정보         |
| :-----: | :---------------------: | :-----------------------: |
| 빈 설정 파일 |     @Configuration      |         \<beans>          |
|  빈의 이름  |   @Bean methodName()    |  \<bean id="methodName">  |
| 빈의 클래스  | return new BeanClass(); | class="a.b.c… BeanClass"> |

```java
@Bean								-->	<bean

public ConnectionMaker

counnectionMaker() {				-->	id="connectionMaker"

	return new DConnectionMaker();
							--> class="springbook...DConnectionMaker" />
}
```



XML에서는 \<property> 태그를 통해 의존 오브젝트와의 관계를 정의한다. \<property> 태그는 name과 ref라는 두 개의 애트리뷰트가 있으며, name은 프로퍼티 이름을 뜻하고 ref는 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름을 의미한다.

```Java
userDao.setConnectionMaker(connectionMaker());
				|						|
                V                       V
<property name="connectionMaker" ref="conntionMaker"/>
```

\<property> 태그의 name과 ref는 그 의미가 다르므로 이름이 같더라도 어떤 차이가 있는지 구별할 수 있어야 한다. name 애트리뷰트는 DI에 사용할 수정자 메소드의 프로퍼티 이름이며, ref 애트리뷰트는 주입할 오브젝트를 정의한 빈의 DI이다.

때로는 같은 인터페이스를 구현한 의존 오브젝트를 여러 개 정의해두고 그 중에서 원하는 걸 골라서 DI하는 경우도 있다. 이때는 각 빈의 이름을 독립적으로 만들어주고 ref 애트리뷰트를 이용해 DI 받을 빈을 지정해주면 된다.

```xml
<bean>
  	<bean id="yourConnectionMaker" class="springbook.user.dao.BConnectionMaer" />
	<bean id="myConnectionMaker"    ------------------------------------ class="springbook.user.dao.DConnectionMaker" />						|
  																	   |
  <bean id="userDao" class="springbook.user.dao.UserDao">			   |
  	<property name="connectionMaker" ref="myConnectionMaker" />   <<<---
  </bean>
</bean>
```

자바에서는 DB 커넥션을 가져오는 오브젝트의 기능을 추상화해서 비슷한 용도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 있다. DataSource는 getConnection()이라는 DB 커넥션을 가져오는 기능 외에도 여러 개의 메소드를 갖고 있다.





































